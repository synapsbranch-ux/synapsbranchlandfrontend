import React, { useState, useMemo } from 'react';
import { useStore } from '../store/useStore';
import { useCanvasStore } from '../store/useCanvasStore';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeHighlight from 'rehype-highlight';
import { Copy, Check, GitBranch, RefreshCw, Pencil, Trash2, MoreHorizontal } from 'lucide-react';
import { toast } from 'sonner';
import CanvasArtifactCard from './CanvasArtifactCard';
import 'highlight.js/styles/github-dark.css';

/**
 * MessageContentRenderer - Parses message content and renders:
 * - Markdown text via ReactMarkdown
 * - Canvas artifact cards via CanvasArtifactCard
 */
const MessageContentRenderer = ({ content }) => {
  const { openCanvas } = useCanvasStore();

  // Parse content for artifact markers
  const parts = useMemo(() => {
    if (!content) return [];

    const ARTIFACT_PATTERN = /\[CANVAS_ARTIFACT:(\w+)\]/g;
    const result = [];
    let lastIndex = 0;
    let match;
    let artifactIndex = 0;

    while ((match = ARTIFACT_PATTERN.exec(content)) !== null) {
      // Add text before the marker
      if (match.index > lastIndex) {
        const textBefore = content.slice(lastIndex, match.index).trim();
        if (textBefore) {
          result.push({ type: 'markdown', content: textBefore, key: `md-${lastIndex}` });
        }
      }

      // Add the artifact card
      result.push({
        type: 'artifact',
        language: match[1],
        key: `artifact-${artifactIndex++}`
      });

      lastIndex = match.index + match[0].length;
    }

    // Add remaining text after last marker
    if (lastIndex < content.length) {
      const remaining = content.slice(lastIndex).trim();
      if (remaining) {
        result.push({ type: 'markdown', content: remaining, key: `md-${lastIndex}` });
      }
    }

    // If no artifacts found, return the whole content as markdown
    if (result.length === 0 && content.trim()) {
      result.push({ type: 'markdown', content: content, key: 'md-0' });
    }

    return result;
  }, [content]);

  return (
    <>
      {parts.map((part) => {
        if (part.type === 'markdown') {
          return (
            <ReactMarkdown
              key={part.key}
              remarkPlugins={[remarkGfm]}
              rehypePlugins={[rehypeHighlight]}
            >
              {part.content}
            </ReactMarkdown>
          );
        } else if (part.type === 'artifact') {
          return (
            <CanvasArtifactCard
              key={part.key}
              artifact={{
                language: part.language,
                content: useCanvasStore.getState().content || '// Code generated by AI'
              }}
            />
          );
        }
        return null;
      })}
    </>
  );
};

const MessageBubble = ({ message }) => {
  const { createBranch, fetchBranches, fetchMessages, currentConversation, regenerateResponse } = useStore();
  const [copied, setCopied] = useState(false);
  const [showActions, setShowActions] = useState(false);
  const [forking, setForking] = useState(false);
  const [editing, setEditing] = useState(false);
  const [forkInput, setForkInput] = useState('');
  const [forkBranchName, setForkBranchName] = useState('');
  const [editContent, setEditContent] = useState(message.content);

  const isUser = message.role === 'user';

  const handleCopy = async () => {
    await navigator.clipboard.writeText(message.content);
    setCopied(true);
    toast.success('Copied to clipboard');
    setTimeout(() => setCopied(false), 2000);
  };

  const handleFork = async () => {
    if (!forkInput.trim() || !forkBranchName.trim()) {
      toast.error('Please enter branch name and message');
      return;
    }
    try {
      await createBranch(message.id, forkBranchName, forkInput);
      toast.success(`Created branch: ${forkBranchName}`);
      setForking(false);
      setForkInput('');
      setForkBranchName('');
      fetchBranches(currentConversation.id);
      fetchMessages(currentConversation.id);
    } catch (e) {
      toast.error('Failed to create branch');
    }
  };

  const handleRegenerate = async () => {
    try {
      await regenerateResponse(message.id);
      toast.success('Regenerating response...');
    } catch (e) {
      toast.error('Failed to regenerate');
    }
  };

  const handleEdit = async () => {
    // Editing creates a fork
    if (!editContent.trim()) return;
    const branchName = `edit-${Date.now()}`;
    try {
      await createBranch(message.parent_id || message.id, branchName, editContent);
      toast.success('Created edit branch');
      setEditing(false);
      fetchBranches(currentConversation.id);
      fetchMessages(currentConversation.id);
    } catch (e) {
      toast.error('Failed to edit');
    }
  };

  return (
    <div
      className={`flex ${isUser ? 'justify-end' : 'justify-start'} animate-fade-in group`}
      data-testid={`message-${message.id}`}
      onMouseEnter={() => setShowActions(true)}
      onMouseLeave={() => !forking && !editing && setShowActions(false)}
    >
      <div className="relative max-w-[85%]">
        {/* Message Content */}
        <div className={isUser ? 'chat-bubble-user' : 'chat-bubble-ai'}>
          {editing ? (
            <div className="space-y-2">
              <textarea
                value={editContent}
                onChange={(e) => setEditContent(e.target.value)}
                className="w-full p-2 bg-background/50 rounded border border-border text-sm resize-none focus:outline-none"
                rows={3}
              />
              <div className="flex justify-end gap-2">
                <button
                  onClick={() => setEditing(false)}
                  className="px-2 py-1 text-xs text-muted-foreground hover:text-foreground"
                >
                  Cancel
                </button>
                <button
                  onClick={handleEdit}
                  className="px-2 py-1 text-xs bg-[hsl(239,84%,67%)] text-white rounded"
                >
                  Save as Branch
                </button>
              </div>
            </div>
          ) : isUser ? (
            <p className="whitespace-pre-wrap">{message.content}</p>
          ) : (
            <div className="markdown-content">
              <MessageContentRenderer content={message.content} />
            </div>
          )}
        </div>

        {/* Hover Actions Menu */}
        {showActions && !editing && (
          <div
            className={`message-actions ${isUser ? 'right-full mr-2' : 'left-full ml-2'} top-0`}
          >
            <button
              onClick={handleCopy}
              className="p-1.5 hover:bg-muted rounded transition-colors"
              title="Copy"
            >
              {copied ? (
                <Check className="w-3.5 h-3.5 text-green-500" />
              ) : (
                <Copy className="w-3.5 h-3.5 text-muted-foreground" />
              )}
            </button>

            {isUser ? (
              // User message actions
              <>
                <button
                  onClick={() => setEditing(true)}
                  className="p-1.5 hover:bg-muted rounded transition-colors"
                  title="Edit (creates branch)"
                >
                  <Pencil className="w-3.5 h-3.5 text-muted-foreground" />
                </button>
              </>
            ) : (
              // AI message actions
              <>
                <button
                  onClick={handleRegenerate}
                  className="p-1.5 hover:bg-muted rounded transition-colors"
                  title="Regenerate"
                >
                  <RefreshCw className="w-3.5 h-3.5 text-muted-foreground" />
                </button>
              </>
            )}

            <button
              onClick={() => setForking(true)}
              className="p-1.5 hover:bg-muted rounded transition-colors"
              title="Branch from here"
              data-testid={`fork-btn-${message.id}`}
            >
              <GitBranch className="w-3.5 h-3.5 text-muted-foreground" />
            </button>
          </div>
        )}

        {/* Model badge for AI messages */}
        {!isUser && message.model_used && !editing && (
          <div className="mt-1 text-xs text-muted-foreground">{message.model_used}</div>
        )}

        {/* Fork dialog */}
        {forking && (
          <div className="fixed inset-0 flex items-center justify-center z-[var(--z-modal)]" onClick={() => { setForking(false); setShowActions(false); }}>
            <div className="bg-card border border-border rounded-lg shadow-xl p-4 w-80 animate-fade-in" onClick={(e) => e.stopPropagation()}>
              <h4 className="text-sm font-medium mb-3">Branch from this message</h4>
              <input
                type="text"
                placeholder="Branch name (e.g., alternative-1)"
                value={forkBranchName}
                onChange={(e) => setForkBranchName(e.target.value)}
                className="w-full px-3 py-2 bg-muted border border-border rounded-md text-sm mb-2 focus:outline-none focus:ring-1 focus:ring-ring"
                data-testid="fork-branch-name-input"
              />
              <textarea
                placeholder="Your new message..."
                value={forkInput}
                onChange={(e) => setForkInput(e.target.value)}
                rows={3}
                className="w-full px-3 py-2 bg-muted border border-border rounded-md text-sm resize-none focus:outline-none focus:ring-1 focus:ring-ring"
                data-testid="fork-message-input"
              />
              <div className="flex justify-end gap-2 mt-3">
                <button
                  onClick={() => {
                    setForking(false);
                    setShowActions(false);
                  }}
                  className="px-3 py-1.5 text-sm text-muted-foreground hover:text-foreground transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleFork}
                  className="px-3 py-1.5 text-sm bg-[hsl(239,84%,67%)] text-white rounded-md hover:bg-[hsl(239,84%,60%)] transition-colors"
                  data-testid="create-fork-btn"
                >
                  Create Branch
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default MessageBubble;
